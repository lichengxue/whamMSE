#' Configure movement random effects
#'
#' The `generate_move()` function is used to configure movement random effects.
#'
#' @param basic_info Information generated by \code{\link{generate_basic_info}}.
#' Note: NAA_where has to be specified in basic_info using \code{\link{generate_NAA_where}}.
#' @param move.type Movement type
#'   \itemize{
#'     \item \code{1} single stock movement (i.e. only stock 1 can move), with region-specific movement rates
#'     \item \code{2} bidirectional movement (i.e. all stocks can move), with region-specific movement rates (default)
#'     \item \code{3} no movement
#'   }
#' @param move.rate Movement rates (default = c(0.3, 0.1))
#' @param move.re Movement random effects
#'   \itemize{
#'     \item \code{"constant"} constant movement rate across years and ages (default).
#'     \item \code{"iid_y"} movement rate deviations vary by year, but uncorrelated (IID).
#'     \item \code{"iid_a"} movement rate deviations vary by age, but uncorrelated (IID).
#'     \item \code{"ar1_y"} movement rate deviations correlated by year (AR1).
#'     \item \code{"ar1_a"} movement rate deviations correlated by age (AR1).
#'     \item \code{"iid_y","iid_a"} vector, movement rate deviations vary by year and ages, but uncorrelated (2D-IID).
#'     \item \code{"ar1_y","ar1_a"} vector, movement rate deviations vary by year and ages (2D-AR1).
#'   }
#' @param move.sigma Standard deviation for movement random effects (default = 0.2)
#' @param prior.sigma Standard deviation for normal priors on mean movement (default = 0.2) 
#' @param move.rho_a Correlation for movement random effects by ages, only used if move.re = "ar1_a" (default = 0.5)
#' @param move.rho_y Correlation for movement random effects by years, only used if move.re = "ar1_y" (default = 0.5)
#' @param use.prior Logical, whether to use priors for movement estimation (default = FALSE)
#' @param move_dyn Movement dynamics. 0 = natal homing, 1 = meta-population
#' 
#' @return A named list with the following components:
#'   \describe{
#'     \item{$stock_move}{Length = n_stocks, TRUE/FALSE whether each stock can move. If not provided, movement will be defined below for all stocks.}
#'     \item{$separable}{Length = n_stocks, TRUE/FALSE whether movement should be modeled separably from mortality or both occurring simultaneously.}
#'     \item{$must_move}{Array (n_stocks x n_seasons x n_regions) 0/1 indicator whether movement from a region must occur.}
#'     \item{$can_move}{Array (n_stocks x n_seasons x n_regions x n_regions) 0/1 indicator whether movement can occur from one region to another.}
#'     \item{$mean_vals}{Array (n_stocks x n_seasons x n_regions x n_regions - 1) of initial movement rate parameters from each region.}
#'     \item{$sigma_vals}{Array (n_stocks x n_seasons x n_regions x n_regions - 1) of initial standard deviations for random effects.}
#'     \item{$cor_vals}{Array (n_stocks x n_seasons x n_regions x n_regions - 1 x 2) of initial correlation values for random effects.}
#'     \item{$use_prior}{Array (n_stocks x n_seasons x n_regions x n_regions - 1) 0/1 indicator whether to include prior for mean movement parameters in joint log-likelihood.}
#'     \item{$prior_sigma}{Array (n_stocks x n_seasons x n_regions x n_regions - 1) of standard deviation parameters for normal priors on mean movement parameters on transformed scale (-Inf,Inf).}
#'   }
#'
#' @export
#'
#' @seealso \code{\link{set_move}} and \code{\link{generate_NAA_where}}
#'
#' @examples
#' \dontrun{
#' data <- generate_basic_info()
#' data <- generate_move(data, move.type = 2, move.rate = c(0.3,0.2), move.re = "constant")
#' }
generate_move <- function(basic_info, 
                          move.type = 2,
                          move.rate = c(0.3, 0.1), 
                          move.re = "constant",
                          move.sigma = 0.2,
                          prior.sigma = 0.2,
                          move.rho_a = 0.5,
                          move.rho_y = 0.5,
                          use.prior = FALSE, 
                          move_dyn = 0) {
  
  if (is.null(basic_info)) stop("basic_info must be provided.")
  
  sep_move <- if(any(names(basic_info) %in% "mig_type")) !as.logical(basic_info$mig_type) else FALSE
  
  n_stocks <- basic_info$n_stocks
  n_regions <- basic_info$n_regions
  n_seasons <- basic_info$n_seasons
  fracyr_spawn <- basic_info$fracyr_spawn
  
  if (n_stocks != n_regions) stop("The current version only allows n_stocks = n_regions") 
  if (length(move.rate) != n_regions) stop("length of movement rates must be equal to n_regions") 
  
  if (!all(move.re %in% c("constant","iid_a","iid_y","ar1_a","ar1_y"))) stop("move.re can only be constant, iid_a, iid_y, ar1_a, ar1_y")
  
  spawntime <- assign_season(fracyr_spawn, basic_info$fracyr_seasons)
  movetime <- setdiff(1:n_seasons, spawntime)
  
  if (move.type != 3 && is.null(move.re)) stop("move.re must be specified unless move.type = 3")
  if (move.type != 3 && is.null(move.rate)) stop("move.rate must be specified unless move.type = 3")
  
  move <- list(stock_move = NULL, separable = sep_move, must_move = NULL, can_move = NULL, mean_vals = NULL)
  
  if (move.type == 1) { # Unidirectional movement
    if(sum(move.rate[2:n_stocks]) != 0) {
      move.rate[2:n_stocks] = 0
      cat("--------Warning--------\n")
      cat("Only stock 1 'can' move so movement rate for other stocks is set to be 0!\n")
      cat("--------Warning--------\n")
    }
    move_mu <- move.rate[1]
    move$stock_move <- c(TRUE, rep(FALSE, n_stocks - 1))
    move$must_move <- array(0, dim = c(n_stocks, n_seasons, n_regions))
    move$can_move <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions))
    
    move$must_move[1, spawntime - 1, setdiff(1:n_regions, 1)] <- 1
    move$can_move[1, movetime, , ] <- 1
    move$can_move[1, spawntime, setdiff(1:n_regions, 1), ] <- 1
    move$can_move[, spawntime, , ] <- 0
    move$can_move[1, spawntime - 1, 1, ] <- 0
    move$can_move[1, spawntime - 1, setdiff(1:n_regions, 1), ] <- 1
    
    move$mean_vals <- array(move_mu, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
    cat(paste0("\nOnly stock 1 'can' move and movement rate is ", move.rate[1], "\n"))
    
    # If n_seasons = 1 (i.e., annual time step)
    if (n_seasons == 1) {
      warnings(paste0("\nn_seasons = 1 will not work for natal homing dynamics!"))
      move$can_move[,1,,] = 1
      diag(move$can_move[1,1,,]) = 0
      move$can_move[-1,1,,] = 0
    }
    
    move <- configure_move.re(move, move.type, move.re, move.sigma, prior.sigma, move.rho_a, move.rho_y, n_stocks, n_seasons, n_regions, use.prior)
    
  } 
  
  if (move.type == 2) { # Bidirectional movement
    
    cat(paste0("\nNote: Movement rate is assumed to be region-specific regardless of stock!\n"))
    
    move_mu <- move.rate
    move$stock_move <- rep(TRUE, n_stocks)
    move$must_move <- array(0, dim = c(n_stocks, n_seasons, n_regions))
    move$can_move <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions))
    cat("\nAll stocks 'can' move\n")
    for (s in 1:n_stocks) {
      move$must_move[s, spawntime - 1, setdiff(1:n_regions, s)] <- 1
      move$can_move[s, movetime, , ] <- 1
      move$can_move[s, spawntime - 1, s, ] <- 0
    }
    
    move$mean_vals <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
    
    for (r in 1:n_regions) {
      move$mean_vals[, , r, ] <- move_mu[r]
      
      cat(paste0("\nMovement rate for stocks in region ",r," is ", move.rate[r],"\n"))
    }
    
    for (r in 1:n_regions) {
      if (move_mu[r] == 0) {
        cat(paste0("\nMovement rate for all stocks in region ",r," to other regions is 0!\n"))
        cat(paste0("\nMake sure elements in the can_move array for region ", r, " are all set 0!\n"))
        move$can_move[,,r,] = 0
      }
    }
    
    # If n_seasons = 1 (i.e., annual time step)
    if (n_seasons == 1) {
      warnings(paste0("\nn_seasons = 1 will not work for natal homing dynamics!"))
      move$can_move[,1,,] = 1
      for (s in 1:n_stocks) diag(move$can_move[s,1,,]) = 0
    }
    
    move <- configure_move.re(move, move.type, move.re, move.sigma, prior.sigma, move.rho_a, move.rho_y, n_stocks, n_seasons, n_regions, use.prior)
    
  } 
  
  if (move.type == 3) { # No movement
    move <- NULL
  }
  
  if (basic_info$move_dyn == 1) { # here is a placeholder for later development
    move$can_move[] = 1
    move$must_move[] = 0
    cat("\nMetapopulation is assumed in the model!\n")
    cat("\nFish are not required to go back during the spawning season.\n")
    cat("\nFish are allowed to move between regions in every season (default).\n")
    cat("\nUsers may specify specific seasons for fish to move externally by changing the move$can_move array.\n")
  }
  
  return(move)
}

# Helper function to configure movement random effects
configure_move.re <- function(move, move.type, move.re, move.sigma, prior.sigma, move.rho_a, move.rho_y, n_stocks, n_seasons, n_regions, use.prior) {
  
  if(length(move.re) == 1) {
    
    if (move.re == "constant") {
      
      cat("\nMovement is assumed at a constant rate without random effects\n")
      move$mean_model <- matrix("constant", n_regions, n_regions - 1)
      
      if (use.prior) {
        cat("\nWarning: Prior for mean movement rate is used!\n")
        cat("\nMean movement rate, although it's still 'constant' across years and ages, \nis now randomly drawn from a prior distribution with a mean and a standard deviation\n")
        move$use_prior <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
        move$use_prior[1, 1, , ] <- 1
        move$prior_sigma <- array(prior.sigma, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
        cat(paste0("\nSigma for the prior for the movement is ",prior.sigma,"\n"))
      } else {
        move$use_prior <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
        move$prior_sigma <- NULL
      }
      
    } else {
      
      cat("\nMovement is treated as random effects\n")
      move$mean_model <- matrix("constant", n_regions, n_regions - 1)
      
      if (use.prior) {
        cat("\nWarning: Prior for mean movement rate is used!\n")
        cat("\nMean movement rate, although it's still 'constant' across years and ages, \nis now randomly drawn from a prior distribution with a mean and a standard deviation\n")
        move$use_prior <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
        move$use_prior[1, 1, , ] <- 1
        move$prior_sigma <- array(prior.sigma, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
        cat(paste0("\nSigma for the prior for the movement is ",prior.sigma,"\n"))
      } else {
        move$use_prior <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
        move$prior_sigma <- NULL
      }
      
      if (move.re %in% c("ar1_y", "iid_y")) {
        cat("\nMovement is treated as varying by years\n")
        if (move.re == "ar1_y") {
          move$year_re <- matrix("ar1", n_regions, n_regions - 1)
          move$cor_vals <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1, 2))
          move$cor_vals[, , , , 2] <- move.rho_y
          cat(paste0("\nar1_y rho for movement is set to ", move.rho_y, "\n"))
        } else if (move.re == "iid_y") {
          move$year_re <- matrix("iid", n_regions, n_regions - 1)
        }
        if(move.type == 1) {
          move$year_re[2:n_regions] = "none"
        }
      }
      
      if (move.re %in% c("ar1_a", "iid_a")) {
        cat("\nMovement is treated as varying by ages\n")
        if (move.re == "ar1_a") {
          move$age_re <- matrix("ar1", n_regions, n_regions - 1)
          move$cor_vals <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1, 2))
          move$cor_vals[, , , , 1] <- move.rho_a
          cat(paste0("\nar1_a rho for movement is set to ", move.rho_a, "\n"))
        } else if (move.re == "iid_a") {
          move$age_re <- matrix("iid", n_regions, n_regions - 1)
        }
        if(move.type == 1) {
          move$age_re[2:n_regions] = "none"
        }
      }
      
      move$sigma_vals = move.sigma
      cat(paste0("\nSigma for the varying movement rate is set to ", move.sigma, "\n"))
    }
  }
  
  if (length(move.re) == 2 && any(move.re %in% c("ar1_y", "iid_y")) && any(move.re %in% c("ar1_a", "iid_a"))) {
    
    cat("\nMovement is treated as 2D random effects\n")
    
    move$mean_model <- matrix("constant", n_regions, n_regions - 1)
    
    if (use.prior) {
      cat("\nWarning: Prior for mean movement rate is used!\n")
      cat("\nMean movement rate, although it's still 'constant' across years and ages, \nis now randomly drawn from a prior distribution with a mean and a standard deviation\n")
      move$use_prior <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
      move$use_prior[1, 1, , ] <- 1
      move$prior_sigma <- array(prior.sigma, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
      cat(paste0("\nSigma for the prior for the movement is ",prior.sigma,"\n"))
    } else {
      move$use_prior <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
      move$prior_sigma <- NULL
    }
    
    if (any(move.re == "ar1_y")) {
      cat("\nMovement is treated as varying by years\n")
      move$year_re <- matrix("ar1", n_regions, n_regions - 1)
      move$cor_vals <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1, 2))
      move$cor_vals[, , , , 2] <- move.rho_y
      cat(paste0("\nar1_y rho for movement is set to ", move.rho_y, "\n"))
    } 
    
    if (any(move.re == "iid_y")) {
      cat("\nMovement is treated as varying by years\n")
      move$year_re <- matrix("iid", n_regions, n_regions - 1)
    }
    
    if(move.type == 1) {
      move$year_re[2:n_regions] = "none"
    }
    
    if (any(move.re == "ar1_a")) {
      cat("\nMovement is treated as varying by ages\n")
      move$age_re <- matrix("ar1", n_regions, n_regions - 1)
      move$cor_vals <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1, 2))
      move$cor_vals[, , , , 1] <- move.rho_a
      cat(paste0("\nar1_a rho for movement is set to ", move.rho_a, "\n"))
    }
    
    if (any(move.re == "iid_a")) {
      cat("\nMovement is treated as varying by ages\n")
      move$age_re <- matrix("iid", n_regions, n_regions - 1)
    }
    
    if(move.type == 1) {
      move$age_re[2:n_regions] = "none"
    }
    
    move$sigma_vals = move.sigma
    cat(paste0("\nSigma for the varying movement rate is set to ", move.sigma, "\n"))
    
  } else {
    warnings("Movement random effects are not specified correctly!")
  }

  return(move)
}

# Helper function to assign seasons
assign_season <- function(fraction, fracyr_seasons) {
  cumulative_season_fractions <- cumsum(fracyr_seasons)
  season <- min(which(fraction <= cumulative_season_fractions))
  return(season)
}
